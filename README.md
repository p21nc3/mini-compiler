# Final Report mini-compiler 
> compiler for an educational C-subset language

**Title:** Mini-compiler for C language<br>
**Author:** Prince Bhardwaj<br>
**Register Number:** RA2011008020062<br>
**Institution:** SRM University, Department of Information Technology<br>
**Course:** 18CSC304J - Compiler Design<br>
**Summary:** A simple compiler that supports basic C language syntax<br>


## Environmental configuration

The tool software that needs to be installed is `flex`, `bison`, `bohemgc`. The specific installation methos is also explained in the document, and one is attacked here for convenience.

Regarding the operating system, I always recommends using a Linux environment (such as Ubuntu, Debian or WSL under Windows, etc.). Of course, you can also develop in a Unix-like system environment (Mac OS). For the C++ experimental framework, you need to install or ensure that the following software meets our requirements:

1. Flex: 

    Flex is a tool that automatically generates lxical analyzers. The lexical analyzers it generates can be used in conjuction with the syntax analyzers generated by Bison. I recommend downloading and installing the lastes version from (GitHub).

    Under Ubuntu, `apt-get install flex` the installed flex version is 2.6, which is available.

    Under Mac OS, it is recommended to use homebrew for installation. `brew install flex`. The installed flex version is 2.6, which is available.

2. Bison

    Bison is a tool that automatically generates sysntax analyzers. The syntax analyzers geneartes can be used in conjuction with the syntax analyzers generated by flex.
 
    Under Ubuntu, I recommend downloading and installing the lastes version from the official website. After downloading and decompressing the tar.gz file, execute it in the path `./configure && make && make install` and it should be installed correctly. If it fails, try `sudo ./configure` `sudo make`, `sudo make install` and then `bison --version` check whether the version is 3.7.6.

    Under Mac OS, it is recommended to use homebrew for installation. `brew install bison`. The installed bison version is 3.7.6, which is available.

    > If you are a Mac OS user, please note that the system may have installed lower versions of flex and bison, and the installed new versions of the tools will be overwritten. You need to confirm the versions of the two through the following command:

    ```
    $ flex --version
    $ bison --version
    ```

    If the version is lower, you need to add the path of the newly installed tool to the environment variable. Regarding the path, on my working system it is:

    ```
    Flex: /usr/local/prince/flex/2.6.4_2/bin
    Bison: /usr/local/prince/bison/3.7.6/bin
    ```

3. Boehmgc

    In the experimental framework of C++ language, In order to simplify the processing of memory allocation, a third party garbage collection library is be used. Simply put, after using the garbage collection library to provide garbage collection function, we can create new in the framework without deleting it. Something will go worng.

    Under Ubuntu, `apt-get install libgc-dev` the boehmgc library is available through installation.

    Under MacOS, `brew install libgc-dev` the boehmgc library is available through installation.

4. The gcc version recommeded is 8.5.0

    > It should be noted that if you use Mac OS for development, the g++ command that comes with Mac is very likely to be soft-linked to clang. Our experimental framework cannot be compiled under sertain versions of clang, so it is recommeded that you the following method to install specific version of gcc. After the installation is complete, you need to use gcc-8, g++-8 to call a specific version og gcc, g++, and you need to modufy the CC and CXX options in the Makefile (I have provided that in the codebase).

    >In addtion, since you are using the g++-8 compiler installed by yourself, you need to add the path to noehmgc to the g++ environment variable:

    ```
    export CPLUS_INCLUDE_PATH = "$CPLUS_INCLUDE_PATH: /usr/local/include"
    export LIBRARY_PATH = "$LIBRARY_PATH: /usr/local/lib"
    export LD_LIBRARY_PATH = "$LD_LIBRARY_PATH: /usr/local/lib"
    ```

    ```
    # Mac OS
    $ brew install gcc@8
    # Ubuntu
    $ sudo apt-get install gcc-8
    ```
> It should be noted that the environment confirguration of C++ is realtively complex, and the tutorial may not cover all issues. Please feel free to drop the issue (if found any) at any time.

## Run method

The Makefile is prepared for you in the experimental framework.  You only need to use the given Makefile to complete the construction of the project. The specific compeltion and running methods are as follows:

   
    $ cd src
    $ make
    $ ./mind -l 5 input.c
    $ ./minf -l 5 -m riscv input.c
    

## Project structure

    Mini-compiler/src
    ├── 3rdparty----------------------------# Third party folder
    |  ├── boehmgc.hpp
    |  ├── hash.hpp
    |  ├── hash_fun.hpp
    |  ├── hash_iterator.hpp
    |  ├── hash_map.hpp
    |  ├── hash_table.hpp
    |  ├── list.hpp
    |  ├── map.hpp
    |  ├── set.hpp
    |  ├── stack.hpp
    |  └── vector.hpp
    ├── asm---------------------------------# Assembly code generation module
    |  ├── mach_desc.hpp					
    |  ├── offset_counter.cpp
    |  ├── offset_counter.hpp
    |  ├── riscv_frame_manager.cpp
    |  ├── riscv_frame_manager.hpp
    |  ├── riscv_md.cpp
    |  └── riscv_md.hpp
    ├── ast---------------------------------# Abstract syntax tree node definition 
    |  ├── ast.cpp
    |  ├── ast.hpp
    |  ├── ast_add_expr.cpp
    |  ├── ast_and_expr.cpp
    |  ├── ast_assign_expr.cpp
    |  ├── ast_bitnot_expr.cpp
    |  ├── ast_bool_const.cpp
    |  ├── ast_bool_type.cpp
    |  ├── ast_cmp_expr.cpp
    |  ├── ast_comp_stmt.cpp
    |  ├── ast_comp_stmt.o
    |  ├── ast_div_expr.cpp
    |  ├── ast_equ_expr.cpp
    |  ├── ast_expr_stmt.cpp
    |  ├── ast_func_defn.cpp
    |  ├── ast_if_stmt.cpp
    |  ├── ast_int_const.cpp
    |  ├── ast_int_type.cpp
    |  ├── ast_lvalue_expr.cpp
    |  ├── ast_mod_expr.cpp
    |  ├── ast_mul_expr.cpp
    |  ├── ast_neg_expr.cpp
    |  ├── ast_neq_expr.cpp
    |  ├── ast_not_expr.cpp
    |  ├── ast_or_expr.cpp
    |  ├── ast_program.cpp
    |  ├── ast_return_stmt.cpp
    |  ├── ast_sub_expr.cpp
    |  ├── ast_var_decl.cpp
    |  ├── ast_var_ref.cpp
    |  ├── ast_while_stmt.cpp
    |  └── visitor.hpp
    ├── frontend----------------------------# Difinition of lexical and grammatical rules
    |  ├── parser.y
    |  └── scanner.l
    ├── scope-------------------------------# Scope module
    |  ├── func_scope.cpp
    |  ├── global_scope.cpp
    |  ├── local_scope.cpp
    |  ├── scope.cpp
    |  ├── scope.hpp
    |  ├── scope_stack.cpp
    |  └── scope_stack.hpp
    ├── symb--------------------------------# Symbol Table definition module
    |  ├── function.cpp
    |  ├── symbol.cpp
    |  ├── symbol.hpp
    |  └── variable.cpp
    ├── tac---------------------------------# Three address code definition data flow diagram model
    |  ├── dataflow.cpp
    |  ├── flow_graph.cpp
    |  ├── flow_graph.hpp
    |  ├── tac.cpp
    |  ├── tac.hpp
    |  ├── trans_helper.cpp
    |  └── trans_helper.hpp
    ├── translation-------------------------# Symbolic truth building, type checking, intermediate code generation blocks
    |  ├── build_sym.cpp
    |  ├── translation.cpp
    |  ├── translation.hpp
    |  └── type_check.cpp
    └── type--------------------------------# definition block
    |  ├── array_type.cpp
    |  ├── base_type.cpp
    |  ├── func_type.cpp
    |  ├── type.cpp
    |  └── type.hpp
    ├── location.hpp------------------------# Record the location in the source file to be compiled
    ├── options.cpp-------------------------# Handle run options, such as <level> and <machine> mentioned above
    ├── options.hpp
    ├── compiler.cpp------------------------# Compiler mian process
    ├── compiler.hpp
    ├── config.hpp
    ├── define.hpp
    ├── error.cpp---------------------------# Definition and processing of compilation errors
    ├── error.hpp
    ├── errorbuf.hpp
    ├── misc.cpp----------------------------# Messy helper functions
    ├── main.cpp
    ├── Makefile
    
    

## illustrate

If anyone encounter problems when using the framework to complete experiments are welcome to raise the PR.

    